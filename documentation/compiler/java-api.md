---
layout: page
title: Java Generated Code
permalink: /documentation/compiler/java/generated-code
---

* Table of Contents
{:toc}

## Overview

This page describes Java code generated by `protostuff-compiler`. 

## Compiler Invocation

### Command Line

### Maven Projects

### Ant Projects

### Gradle Projects

## Compiler Options

| Option             | Description                                             |
|--------------------|---------------------------------------------------------|
| `java_package`     | See [Packages](#packages) section.                      |
| TBD                | TBD                                                     |

## Packages

## Messages

Given a simple message declaration:

~~~proto
message Foo {}
~~~

The `protostuff-compiler` generates a class called `Foo`, which implements the 
`Message` interface. The class is declared `final`; no further subclassing is 
allowed. 

The `Message` interface defines single method:

~~~java
public Schema<T> cachedSchema();
~~~

It returns a `Schema` instance for this class.
 
In addition, `Foo` class defines the following static methods:

* `public static Foo newBuilder()` - creates a new builder instance (described 
  below).
* `public static Schema<SimpleMessage> getSchema()` - returns `Schema` instance
  for this class, same as non-static method `cachedSchema()`.

### Builders

Classes generated by `protostuff-compiler` are effectively immutable. It means
that it is not possible to change message after it is constructed. 

However, they are not fully immutable in java terms - fields are not marked as 
`final`. It is a compromise between safety and performance. We do not want to
allow people modify message instances, but also we do not want to make a full
copy in the builder.

To construct a message object, you need to use a builder instance. Each message 
class has static method to obtain the builder instance - `newBuilder()`.

Builder instance is of the same type as message you are building.

When you call `build()` method it marks message instance as constructed. It is
not possible to change constructed message instance later.

For example,

~~~java
Foo foo = Foo.newBuilder()
                .setBar(bar)
                .build();
~~~

can be rewritten as:

~~~java
Foo foo = Foo.newBuilder();
foo.setBar(bar);
foo = foo.build();
~~~


### Nested Types

A message can be declared inside another message. For example: 

~~~proto
message Foo { 
    message Bar { 
    } 
}
~~~

In this case, the compiler simply generates `Bar` as a static nested class 
inside `Foo`.

## Fields

Protostuff compiler generates a set of accessor methods for each field defined 
within the message in the `.proto` file. 

Method names always use camel-case naming, even if the field name in the 
`.proto` file uses lower-case with underscores (as it should). The 
case-conversion works as follows:

1. For each underscore in the name, the underscore is removed, and the following
   letter is capitalized.
2. If the name will have a prefix attached (e.g. "get"), the first letter is 
   capitalized. Otherwise, it is lower-cased.
   
Thus, the field `foo_bar_baz` becomes `fooBarBaz`. If prefixed with get, it 
would be `getFooBarBaz`.

### Singular Fields

For any of these field definitions:

~~~proto
optional int32 foo = 1;
required int32 foo = 1;
~~~

The compiler will generate the following accessor methods in the message class:

* `boolean hasFoo()`: Returns `true` if the field is set.
* `int getFoo()`: Returns the current value of the field. If the field is not 
  set, returns the default value.
  
The compiler will generate the following methods for constructing new message:

* `MessageT setFoo(int value)`: Sets the value of the field. After calling 
  this, `hasFoo()` will return `true` and `getFoo()` will return value
  
For other simple field types, the corresponding Java type is chosen according to
the scalar value types table. For message and enum types, the value type is 
replaced with the message or enum class.

### Repeated Fields

### Map Fields

For this map field definition:

~~~proto
map<int32, int32> weight = 1;
~~~

The compiler will generate the following accessor methods:

* `Map<Integer, Integer> getWeightMap();`: Returns an unmodifiable `Map`.
* `Integer getWeight(Integer key);`: Returns a value mapped to given key if it
  exists. If mapping does not exist than returns `null`.

The compiler will generate the following methods for constructing new message:

* `MessageT setWeightMap(Map<Integer, Integer> map)`: Sets the value of this map.
* `MessageT putWeight(Integer key, Integer value)`: Adds a mapping for given key
   and value pair.
* `MessageT putAllWeight(Map<Integer, Integer> map)`: Adds all mappings from the
  given map.

### Embedded Message Fields

For message types, setFoo() also accepts an instance of the message's builder type as the parameter. This is just a shortcut which is equivalent to calling .build() on the builder and passing the result to the method.

If the field is not set, getFoo() will return a Foo instance with none of its fields set (possibly the instance returned by Foo.getDefaultInstance()).

In addition, the compiler generates two accessor methods that allow you to access the relevant subbuilders for message types. The following method is generated in both the message class and its builder:

FooOrBuilder getFooOrBuilder(): Returns the builder for the field, if it already exists, or the message if not.
The compiler generates the following method only in the message's builder.

Builder getFooBuilder(): Returns the builder for the field.

## Oneof

## Enumerations

## Extensions

Extensions are not supported.

## Services
